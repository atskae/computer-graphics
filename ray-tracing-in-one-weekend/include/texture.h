#ifndef TEXTURE_H
#define TEXTURE_H

#include "rtweekend.h"
#include "perlin.h"
#include "rtw_stb_image.h" // image utility stb_image


// Abstract base class for a texture
class texture {
    public:
        // (u,v) is the surface coordinate of the ray hit point
        virtual color value(double u, double v, const point3& p) const = 0;
};

// Constant texture
class solid_color : public texture {
    private:
        color color_value;

    public:
        // Constructors
        solid_color() {}
        solid_color(color c): color_value(c) {}
        solid_color(double red, double green, double blue): color_value(color(red, green, blue)) {}

        // Overrided virtual methods
        virtual color value(double u, double v, const point3& p) const override {
            return this->color_value;
        }
};

// Checker texture
class checker_texture: public texture {
    public:
        shared_ptr<texture> odd;
        shared_ptr<texture> even;

        // Constructors
        checker_texture() {}
        
        checker_texture(shared_ptr<texture> _even, shared_ptr<texture> _odd):
            even(_even), odd(_odd) {}
        
        checker_texture(color _even, color _odd):
            even(make_shared<solid_color>(_even)), odd(make_shared<solid_color>(_odd)) {}
        
        // Implement abstract methods of parent class
        // Use the alternating sign of sine and cosine to create a checkered pattern ?!! (wasssss)
        virtual color value(double u, double v, const point3& p) const override {
            // Multiply by 10 so that the coordinates are greater than pi (where the signs change)
            double sines = sin(10*p.x()) * sin(10*p.y()) * sin(10*p.z());
            //double sines = cos(10*p.x()) * cos(10*p.y()) * cos(10*p.z());
            
            // Each axis is alternating signs, which creates a checker patterns when multiplying across axes
            if (sines < 0) {
                return odd->value(u, v, p);
            } else {
                return even->value(u, v, p);
            }
        }
};

class noise_texture: public texture {
    public:
        // Noise generator
        perlin noise;
        // The frequency of the noise (how often the pattern repeats in fixed time)
        // Ex. If scale=2, the pattern repeats twice
        // Ex. If scale=0.5, you need two time units to see the whole pattern
        double scale;
        
        // Constructor
        noise_texture(): scale(1) {}
        noise_texture(double scale): scale(scale) {}

        // Implementation of abstract base class method
        // Create a grey color from the random noise generated by Perlin
        virtual color value(double u, double v, const point3& p) const override {
            // Start with white and apply a random noise
            // The noise value is a random double between [0, 1)
            
            // Block random
            //return color(1,1,1) * this->noise.noise(p);
            
            // Create a marble-like texture
            // Make color proportional to sine()
            // Use turbulence value to adjust the phase (shift sine() left/right) 
            //  To create a phase shift, add to the input `x`: sin(x + phase_shift)
            
            // Compute turblence with increased amplitude
            double phase_shift = 10 * this->noise.turbulence(p);
            // Shift the phase of the sine function
            return color(1,1,1) * 0.5 * (1 + sin(this->scale * p.z() + phase_shift));
            //return color(1,1,1) * 0.5 * (1 + sin(this->scale * p.y() + phase_shift));
            //return color(1,1,1) * 0.5 * (1 + sin(this->scale * p.x() + phase_shift));
        }
};

// Texture class that holds an image texture
class image_texture : public texture {
    private:
        // Texture image as an array of unsigned char (packed RGBs, each component in range [0, 255])
        unsigned char* data;
        // Dimensions of the texture image, in pixels
        int width, height;
        int bytes_per_scanline;

    public:
        // RBG (1 byte per color channel ?)
        const static int bytes_per_pixel = 3;

        // Constructors
        image_texture(): data(nullptr), width(0), height(0), bytes_per_scanline(0) {}
        
        image_texture(const char* filename) {
            // An stb_image "component" = an 8-bit value = a byte
            int components_per_pixel = this->bytes_per_pixel;
            
            // Save the image's pixel data
            this->data = stbi_load(filename, &this->width, &this->height, &components_per_pixel, components_per_pixel);
            if (!this->data) {
                std::cerr << "Failed to read texture image: " << filename << std::endl;
                this->width = this->height = 0;
            }

            this->bytes_per_scanline = bytes_per_pixel * this->width;
        }

        // Destructor
        ~image_texture() {
            delete this->data;
        }

        // Implement abstract base class method
        virtual color value(double u, double v, const point3& p) const override {
            if (!this->data) {
                // If no image data has been loaded, color pixel with constant color for debugging
                return color(0,1,1); // cyan
            }

            // Clamp u to [0, 1] and v to [1, 0]
            // Recall, we have an image that starts at the top-left corner
            //  u goes left to right [0, 1]
            //  v goes bottom to top, [1, 0]
            
            // Review of clamp(): if u < 0.0, return 0.0, if  u > 1.0, return 1.0
            //  Otherwise return u
            u = clamp(u, 0.0, 1.0);
            // (???) Flip v to image coordinates
            v = 1.0 - clamp(v, 0.0, 1.0);

            // Pixel coordinates
            int i = static_cast<int>(u * width);
            int j = static_cast<int>(v * height);

            // More clamping in case i ==  width or j == height (?)
            //  since both u and v could == 1.0
            if (i >= width) i = width - 1;
            if (j >= height) j = height - 1;

            // Get the starting address of pixel (i, j) in the image data
            // start + num_rows + num_columns
            unsigned char* pixel = data + j*this->bytes_per_scanline + i*image_texture::bytes_per_pixel;

            // The color class expects each color channel (R, B, B) to be values between [0, 1)
            // So we divide the image data pixel value by 255 (max color value)
            const double color_scale = 1.0 / 255.0;
            return color(
                color_scale * pixel[0], // red
                color_scale * pixel[1], // green
                color_scale * pixel[2] // blue
            );
        }
};

#endif // header guard
